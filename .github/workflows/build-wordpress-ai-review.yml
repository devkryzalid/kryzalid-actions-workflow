# .github/workflows/build-wordpress-ai-review.yml
name: Build WordPress AI Review

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (staging or production)'
        required: true
        type: string
    secrets:
      # Staging secrets
      SSH_PRIVATE_KEY_STAGING:
        required: false
      SSH_USER_STAGING:
        required: false
      SERVER_HOST_STAGING:
        required: false
      PROJECT_PATH_STAGING:
        required: false
      # Production secrets
      SSH_PRIVATE_KEY_PROD:
        required: false
      SSH_USER_PROD:
        required: false
      SERVER_HOST_PROD:
        required: false
      PROJECT_PATH_PROD:
        required: false
      # Common secrets
      SLACK_BOT_TOKEN:
        required: true
      OPENAI_API_KEY:
        required: true

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets
        run: |
          if [ "${{ inputs.environment }}" = "staging" ]; then
            if [ -z "${{ secrets.SSH_PRIVATE_KEY_STAGING }}" ] || \
               [ -z "${{ secrets.SSH_USER_STAGING }}" ] || \
               [ -z "${{ secrets.SERVER_HOST_STAGING }}" ] || \
               [ -z "${{ secrets.PROJECT_PATH_STAGING }}" ]; then
              echo "Missing required staging secrets"
              exit 1
            fi
          else
            if [ -z "${{ secrets.SSH_PRIVATE_KEY_PROD }}" ] || \
               [ -z "${{ secrets.SSH_USER_PROD }}" ] || \
               [ -z "${{ secrets.SERVER_HOST_PROD }}" ] || \
               [ -z "${{ secrets.PROJECT_PATH_PROD }}" ]; then
              echo "Missing required production secrets"
              exit 1
            fi
          fi

  build:
    needs: validate-secrets
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variables
        id: env
        run: |
          if [ "${{ inputs.environment }}" = "staging" ]; then
            echo "build_command=dev" >> $GITHUB_OUTPUT
          else 
            echo "build_command=build" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ inputs.environment == 'staging' && secrets.SSH_PRIVATE_KEY_STAGING || secrets.SSH_PRIVATE_KEY_PROD }}

      - name: Deploy and build
        env:
          SSH_USER: ${{ inputs.environment == 'staging' && secrets.SSH_USER_STAGING || secrets.SSH_USER_PROD }}
          SERVER_HOST: ${{ inputs.environment == 'staging' && secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST_PROD }}
          PROJECT_PATH: ${{ inputs.environment == 'staging' && secrets.PROJECT_PATH_STAGING || secrets.PROJECT_PATH_PROD }}
        run: |
          ssh -o StrictHostKeyChecking=no $SSH_USER@$SERVER_HOST "\
            cd $PROJECT_PATH && \
            git pull && \
            if [ ! -d "node_modules" ] || [ -n "$(git diff HEAD^ HEAD -- package.json)" ]; then npm ci; fi && \
            npm run ${{ steps.env.outputs.build_command }}"

  notify:
    needs: build
    runs-on: ubuntu-latest
    if: always()
    outputs:
      slack_ts: ${{ steps.send.outputs.ts }}
    steps:
      - name: Clean commit message
        id: clean_message
        run: |
          CLEAN_COMMIT_MESSAGE=$(echo "${{ github.event.head_commit.message }}" | sed ':a;N;$!ba;s/\n/ /g' | sed 's/"/\\"/g')
          echo "clean_commit_message=$CLEAN_COMMIT_MESSAGE" >> $GITHUB_ENV

      - name: Send Slack message (build result)
        id: send
        run: |
          MESSAGE=$(cat <<EOF
          WORDPRESS - *${{ needs.build.result == 'success' && '‚úÖ Build Success for ' || '‚ùå Build Failed for ' }}${{ inputs.environment }} environment*

          *Environment:* ${{ inputs.environment }}
          *Branch:* ${{ github.ref_name }}
          *Commit:* ${{ env.clean_commit_message }}
          *Author:* ${{ github.event.head_commit.author.name }}

          <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|üîç Voir le workflow>
          EOF
          )

          ESCAPED_MESSAGE=$(echo "$MESSAGE" | jq -Rs .)

          RESPONSE=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            -H "Content-type: application/json" \
            -d "{
              \"channel\": \"#kryzabuild\",
              \"text\": $ESCAPED_MESSAGE
            }")

          echo "Slack response: $RESPONSE"

          OK=$(echo "$RESPONSE" | jq -r '.ok')
          TS=$(echo "$RESPONSE" | jq -r '.ts // empty')
          ERROR=$(echo "$RESPONSE" | jq -r '.error // empty')

          if [ "$OK" != "true" ]; then
            echo "Slack message failed: $ERROR"
            exit 1
          fi

          echo "ts=$TS" >> $GITHUB_OUTPUT
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}

  ai-code-review:
    needs: [build, notify]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get PR data
        id: data
        run: |
          echo "title=${{ github.event.head_commit.message }}" >> $GITHUB_OUTPUT
          echo "description=Aucune description fournie dans ce push." >> $GITHUB_OUTPUT

      - name: Get diff
        id: diff
        run: |
          git diff HEAD~1 HEAD > diff.txt
          head -c 20000 diff.txt > truncated_diff.txt
          DIFF=$(cat truncated_diff.txt | base64 | tr -d '\n')
          echo "diff_b64=$DIFF" >> $GITHUB_OUTPUT

      - name: Run AI review
        id: ai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          TITLE="${{ steps.data.outputs.title }}"
          DESC="${{ steps.data.outputs.description }}"
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Ensure we have valid data to work with
          if [ -z "$DIFF" ]; then
            echo "pr_review=Impossible d'analyser le diff (vide)." >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un assistant charg√© de v√©rifier la qualit√© d'une Pull Request (PR) sur un projet WordPress. Le diff est encod√© en base64. D√©code-le avant de l'analyser." \
            --arg user_content "Titre : $TITLE\nDescription : $DESC\nDiff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.3
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "pr_review=Erreur API OpenAI: $HTTP_CODE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract the response
          PR_REVIEW=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "Aucune r√©ponse re√ßue de l'\''IA."')
          
          # Store the raw text output
          echo "pr_review<<EOF" >> $GITHUB_OUTPUT
          echo "$PR_REVIEW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run code review
        id: code_review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Ensure we have valid data to work with
          if [ -z "$DIFF" ]; then
            echo "code_review=Impossible d'analyser le diff (vide)." >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un d√©veloppeur senior WordPress expert (classique et avec Timber/ACF). Tu vas analyser un diff Git encod√© en base64.\n\nD√©code le diff avant de l'analyser. Crit√®res : structure WP, nommage, s√©curit√©, ACF, etc." \
            --arg user_content "Diff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.3
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "code_review=Erreur API OpenAI: $HTTP_CODE" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract the response
          CODE_REVIEW=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "Aucune r√©ponse re√ßue de l'\''IA."')
          
          # Store the raw text output
          echo "code_review<<EOF" >> $GITHUB_OUTPUT
          echo "$CODE_REVIEW" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate success message
        id: success
        if: success()
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          TITLE="${{ steps.data.outputs.title }}"
          DESC="${{ steps.data.outputs.description }}"
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Skip if no diff available
          if [ -z "$DIFF" ]; then
            echo "success_msg=F√©licitations pour cette PR !" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un assistant charg√© de g√©n√©rer un message de f√©licitations pour une PR WordPress r√©ussie. Le diff est encod√© en base64.\n\nMentionne les types de changements (ACF, template, accessibilit√©...) et f√©licite chaleureusement." \
            --arg user_content "Titre : $TITLE\nDescription : $DESC\nDiff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.7
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "success_msg=F√©licitations pour cette PR !" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract the response
          SUCCESS_MSG=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "F√©licitations pour cette PR !"')
          
          # Store the raw text output
          echo "success_msg<<EOF" >> $GITHUB_OUTPUT
          echo "$SUCCESS_MSG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post AI Reviews in Slack thread
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          THREAD_TS: ${{ needs.notify.outputs.slack_ts }}
        run: |
          if [ -z "$THREAD_TS" ]; then
            echo "‚ùå THREAD_TS is empty, cannot reply in thread"
            exit 1
          fi

          # Extract JSON values
          PR_REVIEW_JSON=$(echo "${{ steps.ai.outputs.pr_review }}" | jq -r '.')
          CODE_REVIEW_JSON=$(echo "${{ steps.code_review.outputs.code_review }}" | jq -r '.')
          SUCCESS_MSG_JSON=$(echo "${{ steps.success.outputs.success_msg }}" | jq -r '.')

          # Extract specific fields
          PR_VALID="false"
          PR_COMMENT="Pas de commentaire"
          PR_TITLE="Pas de titre sugg√©r√©"
          PR_DESC="Pas de description sugg√©r√©e"

          CODE_VALID="false"
          CODE_COMMENT="Pas de commentaire"

          SUCCESS_MSG="$SUCCESS_MSG_JSON"

          # Format message using heredoc to handle special characters properly
          MESSAGE=$(cat <<EOF
          ü§ñ *AI Code Review :*

          ## üìù Revue de la PR
          *Validit√©:* $([ "$PR_VALID" = "true" ] && echo "‚úÖ" || echo "‚ùå")
          *Commentaire:* $PR_COMMENT

          $([ "$PR_TITLE" != "Pas de titre sugg√©r√©" ] && echo "*Titre sugg√©r√©:* $PR_TITLE" || echo "")
          $([ "$PR_DESC" != "Pas de description sugg√©r√©e" ] && echo "*Description sugg√©r√©e:* $PR_DESC" || echo "")

          ## üîç Revue technique
          *Validit√©:* $([ "$CODE_VALID" = "true" ] && echo "‚úÖ" || echo "‚ùå")
          $CODE_COMMENT

          ## üéâ F√©licitations
          $SUCCESS_MSG
          EOF
              )

              # Escape the message for JSON
              ESCAPED_MESSAGE=$(echo "$MESSAGE" | jq -Rs .)

              # Send the message in the thread
              curl -X POST https://slack.com/api/chat.postMessage \
                -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
                -H "Content-type: application/json" \
                -d "{
                  \"channel\": \"#kryzabuild\",
                  \"thread_ts\": \"$THREAD_TS\",
                  \"text\": $ESCAPED_MESSAGE
                }"
