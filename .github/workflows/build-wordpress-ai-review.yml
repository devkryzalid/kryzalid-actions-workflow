# .github/workflows/build-wordpress-ai-review.yml
name: Build WordPress AI Review

on:
  workflow_call:
    inputs:
      environment:
        description: 'Target environment (staging or production)'
        required: true
        type: string
    secrets:
      # Staging secrets
      SSH_PRIVATE_KEY_STAGING:
        required: false
      SSH_USER_STAGING:
        required: false
      SERVER_HOST_STAGING:
        required: false
      PROJECT_PATH_STAGING:
        required: false
      # Production secrets
      SSH_PRIVATE_KEY_PROD:
        required: false
      SSH_USER_PROD:
        required: false
      SERVER_HOST_PROD:
        required: false
      PROJECT_PATH_PROD:
        required: false
      # Common secrets
      SLACK_BOT_TOKEN:
        required: true
      OPENAI_API_KEY:
        required: true

jobs:
  validate-secrets:
    runs-on: ubuntu-latest
    steps:
      - name: Check required secrets
        run: |
          if [ "${{ inputs.environment }}" = "staging" ]; then
            if [ -z "${{ secrets.SSH_PRIVATE_KEY_STAGING }}" ] || \
               [ -z "${{ secrets.SSH_USER_STAGING }}" ] || \
               [ -z "${{ secrets.SERVER_HOST_STAGING }}" ] || \
               [ -z "${{ secrets.PROJECT_PATH_STAGING }}" ]; then
              echo "Missing required staging secrets"
              exit 1
            fi
          else
            if [ -z "${{ secrets.SSH_PRIVATE_KEY_PROD }}" ] || \
               [ -z "${{ secrets.SSH_USER_PROD }}" ] || \
               [ -z "${{ secrets.SERVER_HOST_PROD }}" ] || \
               [ -z "${{ secrets.PROJECT_PATH_PROD }}" ]; then
              echo "Missing required production secrets"
              exit 1
            fi
          fi

  build:
    needs: validate-secrets
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variables
        id: env
        run: |
          if [ "${{ inputs.environment }}" = "staging" ]; then
            echo "build_command=dev" >> $GITHUB_OUTPUT
          else 
            echo "build_command=build" >> $GITHUB_OUTPUT
          fi

      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up SSH key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ inputs.environment == 'staging' && secrets.SSH_PRIVATE_KEY_STAGING || secrets.SSH_PRIVATE_KEY_PROD }}

      - name: Deploy and build
        env:
          SSH_USER: ${{ inputs.environment == 'staging' && secrets.SSH_USER_STAGING || secrets.SSH_USER_PROD }}
          SERVER_HOST: ${{ inputs.environment == 'staging' && secrets.SERVER_HOST_STAGING || secrets.SERVER_HOST_PROD }}
          PROJECT_PATH: ${{ inputs.environment == 'staging' && secrets.PROJECT_PATH_STAGING || secrets.PROJECT_PATH_PROD }}
        run: |
          ssh -o StrictHostKeyChecking=no $SSH_USER@$SERVER_HOST "\
            cd $PROJECT_PATH && \
            git pull && \
            if [ ! -d "node_modules" ] || [ -n "$(git diff HEAD^ HEAD -- package.json)" ]; then npm ci; fi && \
            npm run ${{ steps.env.outputs.build_command }}"

  ai-code-review:
    needs: [build, notify]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get PR data
        id: data
        run: |
          echo "title=${{ github.event.head_commit.message }}" >> $GITHUB_OUTPUT
          echo "description=Aucune description fournie dans ce push." >> $GITHUB_OUTPUT

      - name: Get diff
        id: diff
        run: |
          git diff HEAD~1 HEAD > diff.txt
          head -c 20000 diff.txt > truncated_diff.txt
          DIFF=$(cat truncated_diff.txt | base64 | tr -d '\n')
          echo "diff_b64=$DIFF" >> $GITHUB_OUTPUT

      - name: Run AI review
        id: ai
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          TITLE="${{ steps.data.outputs.title }}"
          DESC="${{ steps.data.outputs.description }}"
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Ensure we have valid data to work with
          if [ -z "$DIFF" ]; then
            echo "pr_review={\"valid\":false,\"comment\":\"Impossible d'analyser le diff (vide).\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un assistant charg√© de v√©rifier la qualit√© d'une Pull Request (PR) sur un projet WordPress. Le diff est encod√© en base64. D√©code-le avant de l'analyser. R√©ponds dans le format JSON : {\"valid\": true|false, \"comment\": \"...\", \"suggested_title\": \"...\", \"suggested_description\": \"...\"}" \
            --arg user_content "Titre : $TITLE\nDescription : $DESC\nDiff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.3
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "pr_review={\"valid\":false,\"comment\":\"Erreur API OpenAI: $HTTP_CODE\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract and validate the response
          PR_REVIEW=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "Aucune r√©ponse re√ßue de l'\''IA."')
          
          # Ensure the output is valid JSON, or provide a fallback
          if ! echo "$PR_REVIEW" | jq empty 2>/dev/null; then
            PR_REVIEW="{\"valid\":false,\"comment\":\"$PR_REVIEW\"}"
          fi
          
          # Escape for GitHub output
          PR_REVIEW_ESCAPED=$(echo "$PR_REVIEW" | jq -c -R .)
          echo "pr_review=$PR_REVIEW_ESCAPED" >> $GITHUB_OUTPUT

      - name: Run code review
        id: code_review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Ensure we have valid data to work with
          if [ -z "$DIFF" ]; then
            echo "code_review={\"valid\":false,\"formattedComment\":\"Impossible d'analyser le diff (vide).\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un d√©veloppeur senior WordPress expert (classique et avec Timber/ACF). Tu vas analyser un diff Git encod√© en base64.\n\nD√©code le diff avant de l'analyser. Crit√®res : structure WP, nommage, s√©curit√©, ACF, etc. R√©ponds dans le format : { \"valid\": true|false, \"formattedComment\": \"...\" }" \
            --arg user_content "Diff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.3
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "code_review={\"valid\":false,\"formattedComment\":\"Erreur API OpenAI: $HTTP_CODE\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract and validate the response
          CODE_REVIEW=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "Aucune r√©ponse re√ßue de l'\''IA."')
          
          # Ensure the output is valid JSON, or provide a fallback
          if ! echo "$CODE_REVIEW" | jq empty 2>/dev/null; then
            CODE_REVIEW="{\"valid\":false,\"formattedComment\":\"$CODE_REVIEW\"}"
          fi
          
          # Escape for GitHub output
          CODE_REVIEW_ESCAPED=$(echo "$CODE_REVIEW" | jq -c -R .)
          echo "code_review=$CODE_REVIEW_ESCAPED" >> $GITHUB_OUTPUT

      - name: Generate success message
        id: success
        if: success()
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        shell: bash
        run: |
          TITLE="${{ steps.data.outputs.title }}"
          DESC="${{ steps.data.outputs.description }}"
          DIFF="${{ steps.diff.outputs.diff_b64 }}"

          # Skip if no diff available
          if [ -z "$DIFF" ]; then
            echo "success_msg={\"success_message\":\"F√©licitations pour cette PR !\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Create payload with proper JSON escaping
          PAYLOAD=$(jq -n \
            --arg model "gpt-4-0125-preview" \
            --arg system_content "Tu es un assistant charg√© de g√©n√©rer un message de f√©licitations pour une PR WordPress r√©ussie. Le diff est encod√© en base64.\n\nMentionne les types de changements (ACF, template, accessibilit√©...) et f√©licite chaleureusement. Format attendu : { \"success_message\": \"...\" }" \
            --arg user_content "Titre : $TITLE\nDescription : $DESC\nDiff Git (base64) :\n$DIFF" \
            '{
              model: $model,
              messages: [
                {
                  role: "system",
                  content: $system_content
                },
                {
                  role: "user",
                  content: $user_content
                }
              ],
              temperature: 0.7
            }')

          # Make API call with proper error handling
          RESPONSE=$(curl -s -w "\n%{http_code}" https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | sed '$ d')
          
          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "success_msg={\"success_message\":\"F√©licitations pour cette PR !\"}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Extract and validate the response
          SUCCESS_MSG=$(echo "$RESPONSE_BODY" | jq -r '.choices[0].message.content // "F√©licitations pour cette PR !"')
          
          # Ensure the output is valid JSON, or provide a fallback
          if ! echo "$SUCCESS_MSG" | jq empty 2>/dev/null; then
            SUCCESS_MSG="{\"success_message\":\"$SUCCESS_MSG\"}"
          fi
          
          # Escape for GitHub output
          SUCCESS_MSG_ESCAPED=$(echo "$SUCCESS_MSG" | jq -c -R .)
          echo "success_msg=$SUCCESS_MSG_ESCAPED" >> $GITHUB_OUTPUT

      - name: Post AI Reviews in Slack thread
        run: |
          # Extract JSON values
          PR_REVIEW_JSON=$(echo '${{ steps.ai.outputs.pr_review }}' | jq -r '.')
          CODE_REVIEW_JSON=$(echo '${{ steps.code_review.outputs.code_review }}' | jq -r '.')
          SUCCESS_MSG_JSON=$(echo '${{ steps.success.outputs.success_msg }}' | jq -r '.')
          
          # Extract specific fields
          PR_VALID=$(echo "$PR_REVIEW_JSON" | jq -r '.valid // false')
          PR_COMMENT=$(echo "$PR_REVIEW_JSON" | jq -r '.comment // "Pas de commentaire"')
          PR_TITLE=$(echo "$PR_REVIEW_JSON" | jq -r '.suggested_title // "Pas de titre sugg√©r√©"')
          PR_DESC=$(echo "$PR_REVIEW_JSON" | jq -r '.suggested_description // "Pas de description sugg√©r√©e"')
          
          CODE_VALID=$(echo "$CODE_REVIEW_JSON" | jq -r '.valid // false')
          CODE_COMMENT=$(echo "$CODE_REVIEW_JSON" | jq -r '.formattedComment // "Pas de commentaire"')
          
          SUCCESS_MSG=$(echo "$SUCCESS_MSG_JSON" | jq -r '.success_message // "F√©licitations pour cette PR !"')
          
          # Format message using heredoc to handle special characters properly
          MESSAGE=$(cat <<EOF
          ü§ñ *AI Code Review :*

          ## üìù Revue de la PR
          *Validit√©:* $([ "$PR_VALID" = "true" ] && echo "‚úÖ" || echo "‚ùå")
          *Commentaire:* $PR_COMMENT

          $([ "$PR_TITLE" != "Pas de titre sugg√©r√©" ] && echo "*Titre sugg√©r√©:* $PR_TITLE" || echo "")
          
          $([ "$PR_DESC" != "Pas de description sugg√©r√©e" ] && echo "*Description sugg√©r√©e:* $PR_DESC" || echo "")
          
          ## üîç Revue technique
          *Validit√©:* $([ "$CODE_VALID" = "true" ] && echo "‚úÖ" || echo "‚ùå")
          $CODE_COMMENT
          
          $([ "$CODE_VALID" = "true" ] && echo "## üéâ F√©licitations\n$SUCCESS_MSG" || echo "")
          EOF
          )
          
          # Escape the message for JSON
          ESCAPED_MESSAGE=$(echo "$MESSAGE" | jq -Rs .)
          
          # Check if thread_ts exists, use fallback if not
          THREAD_TS="${{ needs.notify.outputs.slack_ts }}"
          if [ -z "$THREAD_TS" ]; then
            # Send as a new message if no thread_ts is available
            curl -X POST https://slack.com/api/chat.postMessage \
              -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
              -H "Content-type: application/json" \
              -d "{
                \"channel\": \"#kryzabuild\",
                \"text\": $ESCAPED_MESSAGE
              }"
          else
            # Send as a thread reply
            curl -X POST https://slack.com/api/chat.postMessage \
              -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
              -H "Content-type: application/json" \
              -d "{
                \"channel\": \"#kryzabuild\",
                \"thread_ts\": \"$THREAD_TS\",
                \"text\": $ESCAPED_MESSAGE
              }"
          fi
  notify:
    needs: build
    runs-on: ubuntu-latest
    if: always()
    outputs:
      slack_ts: ${{ steps.send.outputs.ts }}
    steps:
      - name: Clean commit message
        id: clean_message
        run: |
          CLEAN_COMMIT_MESSAGE=$(echo "${{ github.event.head_commit.message }}" | sed ':a;N;$!ba;s/\n/ /g' | sed 's/"/\\"/g')
          echo "clean_commit_message=$CLEAN_COMMIT_MESSAGE" >> $GITHUB_ENV

      - name: Send Slack message (build result)
        id: send
        run: |
          MESSAGE=$(cat <<EOF
          WORDPRESS - *${{ needs.build.result == 'success' && '‚úÖ Build Success for ' || '‚ùå Build Failed for ' }}${{ inputs.environment }} environment*

          *Environment:* ${{ inputs.environment }}
          *Branch:* ${{ github.ref_name }}
          *Commit:* ${{ env.clean_commit_message }}
          *Author:* ${{ github.event.head_commit.author.name }}

          <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|üîç Voir le workflow>
          EOF
          )
          
          ESCAPED_MESSAGE=$(echo "$MESSAGE" | jq -Rs .)
          
          RESPONSE=$(curl -s -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            -H "Content-type: application/json" \
            -d "{
              \"channel\": \"#kryzabuild\",
              \"text\": $ESCAPED_MESSAGE
            }")

          echo "ts=$(echo $RESPONSE | jq -r '.ts // ""')" >> $GITHUB_OUTPUT
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
